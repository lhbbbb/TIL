# 자료구조

## Array vs Linked List

### Array

- 가장 기본적인 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 일치
- 인덱스로 해당 원소에 접근 가능
- 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한 뒤, shift 작업을 추가적으로 해줘야 하기 때문에 시간이 더 걸림
- 삭제 또는 삽입 과정에서 최악의 경우 O(n)의 시간을 요구하게 됨

### Linked List

- 삭제나 삽입 과정에서 생기는 문제점을 해결하기 위한 자료구조
- 각각의 원소들은 자기 다음에 어떤 원소인지만을 기억
- 따라서 이 부분만 다른 값으로 바꿔준다면 삭제와 삽입을 O(1)만에 해결 가능
- 하지만 원하는 위치에 삽입하고자 할 때 Search 과정에 있어서 첫번째 원소부터 다 확인해야함. Array와 달리 논리적, 물리적 저장 순서가 일치하지 않기 때문
- 이 과정 때문에, 어떠한 원소를 삭제나 추가할 때 해당 원소를 찾기 위해 O(n)의 시간이 추가적으로 발생
- 결국 search에도 O(n)의 시간복잡도를 갖고, 삽입 삭제에 대해서도 O(n)의 시간복잡도를 가지게 됨
- 따지고보면 Array의 문제점을 극복했다고 볼 수 없으나 이후 Tree 자료구조의 근간이 되는 자료구조임

## Stack and Queue

### Stack

- 선형 자료구조

- LIFO(Last in First out): 나중에 들어간 원소가 먼저 나옴

### Queue

- 선형 자료구조

- FIFO(First in First out): 먼저 들어간 원소가 먼저 나옴

## Tree

- 선형 구조가 아닌 비선형 자료구조
- 계층적 관계를 표현함

#### 트리의 구성요소

- Node: 트리를 구성하고 있는 각각의 요소
- Edge: 트리를 구성하기 위해 노드와 노드를 연결하는 선
- Root Node: 트리 구조에서 최상위 노드
- Terminal Node: 하위에 다른 노드가 연결되어 있지 않은 노드
- Internal Node: 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다

###  Binary Tree

루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다. 나뉘어진 서브 트리도 이진 트리여야 한다. 공집합도 이진 트리로 포함시켜야 한다.

- 포화 이진 트리: 모든 레벨이 꽉 찬 이진 트리
- 완전 이진 트리: 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리
- 정 이진 트리: 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리

## Hash Table

- hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다
- 데이터 고유의 인덱스로 접근하므로 시간복잡도가 O(1)
- 인덱스로 저장되는 key 값이 불규칙하다
- 따라서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 이를 인덱스로 사용한다

