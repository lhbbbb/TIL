# 징검다리

###### 문제 설명

출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

| 제거한 바위의 위치 | 각 바위 사이의 거리 | 거리의 최솟값 |
| ------------------ | ------------------- | ------------- |
| [21, 17]           | [2, 9, 3, 11]       | 2             |
| [2, 21]            | [11, 3, 3, 8]       | 3             |
| [2, 11]            | [14, 3, 4, 4]       | 3             |
| [11, 21]           | [2, 12, 3, 8]       | 2             |
| [2, 14]            | [11, 6, 4, 4]       | 4             |

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

##### 제한사항

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 `바위의 개수` 이하입니다.

##### 입출력 예

| distance | rocks               | n    | return |
| -------- | ------------------- | ---- | ------ |
| 25       | [2, 14, 11, 21, 17] | 2    | 4      |

##### 입출력 예 설명

문제에 나온 예와 같습니다.

[출처](http://contest.usaco.org/DEC06.htm)

## 문제 해결

프로그래머스의 이분탐색 카테고리에 있는 level4 짜리 문제를 처음 풀어보았다. 앞서 level3짜리 입국심사 문제를 풀어보면서 이분탐색 문제를 풀 때는 사고의 전환이 중요하다는 점을 깨달았는데, 이 문제 역시 마찬가지였다. 이분탐색에 익숙해지기 위해서는 여러 문제를 풀어봐야할 것 같다...

이분 탐색 문제를 해결하기 위해서는 다음과 같은 기준을 잘 정해야 한다.

1. 이분탐색에서 찾을 값이 무엇인지 정의
2. 왼쪽, 오른쪽 값을 변화시키는 기준이 무엇인지 정의

이제 이 기준을 가지고 문제를 살펴보도록 한다.

먼저 우리가 여기서 찾아야 할 값은 **각 지점 사이의 거리의 최솟값**이다. 보퉁 문제에서 찾아야 하는 목적 값을 이분탐색에서 찾아야 할 값으로 주어지는 경우가 많은 것 같다.

이제 찾을 값을 정의했으니 어떻게 최솟값의 탐색 범위를 결정지을 수 있는지 생각해본다. 문제에서 **바위를 n개 제거한 최솟값**이라고 했으니 이를 사용해보면 될 것 같다.

1. 바위를 오름차순 정렬한다.

2. 바위와 바위사이의 간격은 각 지점 사이의 거리이므로 이 거리가 최솟값보다 큰 지 작은지 확인한다.

   - 최솟값보다 크면 살려도 되는 바위이다.

   - 최솟값보다 작으면 제거하고 제거 바위 수를 카운트한다.

3. 최솟값의 탐색 범위를 갱신한다.

그렇다면 바위를 제거한 수 n이 늘어날 수록 최솟값의 범위는 어떻게 되는 것일까? 바위를 제거한 수가 적을수록 바위간의 간격은 촘촘할 것이고 최솟값은 당연히 작아질 수 밖에 없을 것이다. 반대로 바위를 많이 제거할수록 바위간의 간격은 넓어질 것이고 최솟값 역시 커질 수 밖에 없다.

이제 어느 정도는 다 정리된 것 같다. 그렇다면 마지막 항목인 최솟값 중에 가장 큰 값을 찾으려면 어떻게 해야할까?

이분탐색의 속성을 떠올려보자. 우측 탐색 범위는 자신보다 큰 값의 범위를 계속해서 탐색하는 방법이고 좌측 탐색 범위는 자신보다 작은 값의 범위를 계속해서 탐색한다. 따라서 우측 탐색범위에서 최솟값을 갱신하게 하면 해결된다.

이를 토대로 코드를 구현해보자.

```python
def solution(distance, rocks, n):
    answer = 0
    
    rocks.sort()
    rocks.append(distance)
    
    l = 1
    r = distance
    
    while l <= r:
        mid = (l+r) // 2
        ele_lst = [] # 제거해야할 바위
        alive = [0] # 살리는 바위
        for ele in rocks:
            if ele - alive[-1] < mid:
                ele_lst.append(ele)
            else:
                alive.append(ele)
        
        # print(mid, ele_lst)
        if len(ele_lst) > n:
            r = mid - 1
        else:
            answer = mid
            l = mid + 1
        
    return answer
```

