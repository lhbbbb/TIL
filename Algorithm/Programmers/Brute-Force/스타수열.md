###### 문제 설명

다음과 같은 것들을 정의합니다.

- 어떤 수열 x의 [부분 수열(Subsequence)](https://en.wikipedia.org/wiki/Subsequence)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.
  - 예를 들어, `[1,3]`은 `[1,2,3,4,5]`의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
- 다음과 같은 조건을 모두 만족하는 수열 x를 **스타 수열**이라고 정의합니다.
  - x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
  - x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 `{x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]}` 의 교집합의 원소의 개수가 1 이상입니다.
  - `x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1]` 입니다.
  - 예를 들어, `[1,2,1,3,4,1,1,3]`은 스타 수열입니다. `{1,2}, {1,3}, {4,1}, {1,3}` 의 교집합은 `{1}` 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

------

##### 제한사항

- a의 길이는 1 이상 500,000 이하입니다.
  - a의 모든 수는 0 이상 (a의 길이) 미만입니다.

------

##### 입출력 예

| a                       | result |
| ----------------------- | ------ |
| `[0]`                   | 0      |
| `[5,2,3,3,5,3]`         | 4      |
| `[0,3,3,0,7,2,0,2,2,0]` | 8      |

------

##### 입출력 예 설명

입출력 예 #1

- a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다.

입출력 예 #2

- `[5,2,5,3]`, `[5,3,3,5]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다.

입출력 예 #3

- `[0,3,3,0,7,0,2,0]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다.

※ 공지 - 2020년 11월 27일 테스트케이스가 추가되었습니다.



## 문제풀이

제한사항에서 배열의 길이가 500,000 이하라고 했기 때문에 완전탐색으로 해결할 시 최악의 경우, $O(500,000^2)$이 되어버려 시간초과가 난다. 그렇다면 적절하게 가지치기를 해주는 백트래킹 방법이나 그리디, dp같은 방법으로 해결해야 한다. 위에서 언급한 방법들 중 dp는 아닌 것 같아 백트래킹과 그리디를 활용하여 문제를 풀어보았다. 아무리 생각해도 $O(n)$으로 해결하는 방법은 떠오르지가 않았다..



먼저 스타수열이 되기 위한 조건들은 다음과 같다.

1. 배열의 길이가 2이상인 짝수여야 한다.
2. 배열을 두 개씩 연속하는 원소들로 나눴을 때, 나눈 집합들의 교집합이 반드시 1개 이상은 존재해야한다.
3. 두 개의 연속하는 원소들로 이뤄진 집합 내의 원소들은 서로 다른 값을 가지고 있어야 한다.



여기서 문제를 해결하기 위한 key 조건은 2번 조건이다. 교집합이 반드시 1개 이상은 존재해야 한다는 말은 **특정한 원소를 반드시 가지고 있어야 한다**는 말이 된다. 이는 주어진 배열에서 각 원소들의 빈도 수를 세었을 때, 배열에서 나올 수 있는 최장 길이의 스타수열은 가장 빈도수가 높은 원소에서 나온다는 말이 된다. 물론 이는 1번과 3번 조건이 없다고 가정할 때 성립된다.

2번 조건으로 빈도 수가 높은 원소에서 최장 길이를 가진 스타수열이 나올 가능성이 높다는 것을 알았으니, 해당 원소의 빈도수를 체크한 다음에 빈도수가 가장 높은 원소부터 차례대로 해당 원소를 반드시 사용하면서 1,3 의 조건을 만족하는 부분수열을 검사하면 되겠지만 구현에서는 순서를 가진 딕셔너리를 사용하기 귀찮아 그냥 풀었다.



```python
def solution(a):
    answer = -1
    n = len(a)
    if n <= 1:
        return 0
    
    chk = {}
    # 빈도수 세기
    for ele in a:
        if not chk.get(ele):
            chk[ele] = 0
        chk[ele] += 1
    
    for k in chk:
        lst = []
        cnt = 0
        # 가지치기
        if chk[k] > answer:
            # 부분수열 검사
            for ele in a:
                if not lst:
                    lst.append(ele)
                    continue
                if ele == k:
                    if k not in lst:
                        lst.append(ele)
                else:
                    if k in lst:
                        lst.append(ele)
                    
                if len(lst) == 2:
                    cnt += 1
                    lst = []
            if answer < cnt:
                answer = cnt
                    
    answer *= 2
    return answer
```

#### 후기

처음에 이 문제를 봤을 때 가지치기를 해도 문제에서 최악의 경우가 주어지면 $O(n^2)$이 걸릴 것이라 생각해서 어떻게든 $O(n)$으로 접근하려해서 어렵게 느껴졌었던 것 같다. 그리고 생각보다 두번째 조건에서 빈도수 아이디어를 떠올리기가 힘들었고, 부분수열 검사하는 부분을 만들기가 까다로웠던 것 같다.

아직도 내가 한참 부족하다는 생각이 들게 해주는 문제였고 빨리 자연스럽게 풀이 방법이 떠오르는 날이 오면 좋겠다.