###### 문제 설명

Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.

예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

- 1원을 5개 사용해서 거슬러 준다.
- 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
- 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
- 5원을 1개 사용해서 거슬러 준다.

거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.

##### 제한 사항

- n은 100,000 이하의 자연수입니다.
- 화폐 단위는 100종류 이하입니다.
- 모든 화폐는 무한하게 있다고 가정합니다.
- 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

------

##### 입출력 예

| n    | money   | result |
| ---- | ------- | ------ |
| 5    | [1,2,5] | 4      |

##### 입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.

## 문제 해결

전형적인 동적계획법(Dynamic Programming) 문제이다. 문제 해결을 위해 다음과 같이 표를 그려본다.

|           |  1   |  2   |  3   |  4   |  5   |
| --------- | :--: | :--: | :--: | :--: | :--: |
| 1 (1)     |  1   |  1   |  1   |  1   |  1   |
| 2 (1,2)   |  1   |  2   |      |      |      |
| 5 (1,2,5) |  1   |  2   |      |      |      |

표에서 열에 해당하는 부분은 만들어야 하는 거스름돈 n이고, 행에 해당하는 부분은 사용할 수 있는 동전이다. 결국 이 행열을 dp라고 했을 때, i를 사용하여 j원을 거슬러주기 위한 방법의 수 $dp[i][j]$를 구해야한다.

1원짜리 종류만 사용해서 구할 수 있는 경우의 수는 1개 뿐이라는 것은 직관적으로 알 수 있다. 그렇다면 나머지 빈 칸은 어떻게 채울 수 있을까? 먼저 동적계획법을 해결하기 위한 절차를 떠올려보자.

1. 문제를 가능한 작은 부분 문제로 쪼갠다.
2. 부분 문제들의 최적해를 사용하여 전역적 최적해를 구한다. => 점화식을 세운다.

위의 사항을 숙지하고 (1,2) 원을 사용할 때를 생각해보자. 1원을 (1,2) 원으로 만드는 방법은 1원만 사용했을 때와 같다.

2원을 (1,2)원으로 만드는 방법은 2원을 1원짜리로 만드는 경우 + 2원짜리 하나를 사용했을 경우이므로 1만 더해주면 된다.

3원 이후부터는 다음과 같은 부분문제로 쪼갤 수 있다.

>2원짜리를 사용하지 않고 3원을 만드는 경우 + 2원짜리를 무조건 사용하여 3원을 만드는 경우
>
>=  1원만 사용하여 3원을 만드는 경우 + (3-2)원을 (1,2)원을 사용하여 만드는 경우

위의 방법을 사용하여 표를 다시 만들어본다.

|           |  1   |  2   |  3   |  4   |  5   |
| --------- | :--: | :--: | :--: | :--: | :--: |
| 1 (1)     |  1   |  1   |  1   |  1   |  1   |
| 2 (1,2)   |  1   |  2   |  2   |  3   |  3   |
| 5 (1,2,5) |  1   |  2   |  2   |  3   |  4   |

```python
def solution(n, money):
    money_lst = [[0] * n for _ in range(len(money))]
    money.sort()
    for idx in range(money[0]-1, n, money[0]):
        money_lst[0][idx] = 1
    for i in range(1, len(money)):
        for j in range(n):
            if j < i:
                money_lst[i][j] = money_lst[i-1][j]
            elif j == money[i]-1:
                money_lst[i][j] = money_lst[i-1][j] + 1
            else:
                money_lst[i][j] = money_lst[i-1][j] + money_lst[i][j-money[i]]
    
    answer = money_lst[-1][-1] % 1000000007
    return answer
```