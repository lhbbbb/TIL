###### 문제 설명

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

![image.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/e7dd4f51c3/a228c73d-1cbe-4d59-bb5d-833fd18d3382.png)

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

##### 제한사항

- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
- money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

##### 입출력 예

| money        | return |
| ------------ | ------ |
| [1, 2, 3, 1] | 4      |

## 문제풀이

전형적인 dp 문제이다. 문제를 보자마자 제한사항을 보고 dp의 냄새가 느껴졌지만, 바로 풀 수는 없었다. 그동안 백준 퇴사나, 프로그래머스 레벨 3의 dp문제들을 풀면서 유형에 꽤 익숙해졌다고 생각했는데, 아직 사고력이 부족한 것 같다. 더 많은 문제들을 풀어봐야할 것 같다.

다른 사람들의 풀이를 참고한 풀이법은 다음과 같다.

먼저 주어진 입력값들이 원형 형태가 아니라 직선형이라고 가정해보자. 보통 이렇게 원형으로 순환구조를 이루는 문제들은 직선형이라고 가정한 뒤 순환형이었을 때를 조건으로 주고 푸는 게 더 쉬운 접근 방법인 것 같다.

직선형이라고 가정한 뒤, dp[i]를 도둑이 i번째 집까지 털었을 때 얻을 수 있는 최대 수익이라고 생각해보자.

1. 집이 한 개 있을 때의 dp[1] 값은 그 집에 있는 돈이다.
2. 집이 두 개 있을 때의 dp[2] 값은 첫번째 집과 두번째 집에 있는 돈 중 더 큰 값이다.
3. 집이 세 개 있을 때의 dp[3] 값은 두번째 집까지 털었을 때 얻은 수익과 세번째 집을 턴 수익 + 세번째 집과 인접하지 않은 첫번째 집까지 털었을 때 얻은 수익을 합한 값 중 더 큰 값이다.

이를 바탕으로 다음과 같은 점화식을 세울 수 있다.
$$
dp[i] = max(dp[i-1], money[i] + dp[i-2])
$$
점화식을 세웠으니 남은 것은 이제 첫번째 집과 마지막 집이 인접하고 있다는 정보를 이용해주는 것이다. 이를 다음과 같이 두 가지 경우로 나눌 수 있다.

1. 도둑이 첫번째 집을 무조건 털 경우 마지막 집은 빼고 생각해야한다.
2. 도둑이 마지막 집을 무조건 털 경우 첫번째 집은 빼고 생각해야한다.

```python
def solution(money):
    answer = 0
    # dp[i] = i번째 집을 털었을 때 최대 수익
    ## case 1
    dp1 = [0] * (len(money)-1)
    ### init settings
    dp1[0] = money[0]
    dp1[1] = max(money[0], money[1])
    ### solve
    for i in range(2, len(money)-1):
        dp1[i] = max(dp1[i-1], money[i] + dp1[i-2])
    ## case 2
    dp2 = [0] * (len(money)-1)
    ### init settings
    money.pop(0)
    dp2[0] = money[0]
    dp2[1] = max(money[0], money[1])
    ### solve
    for i in range(2, len(money)):
        dp2[i] = max(dp2[i-1], money[i] + dp2[i-2])
    
    answer = max(dp1[-1], dp2[-1])
    return answer
```

dp 문제를 풀 때 가장 중요한 점은 문제를 작은 문제들로 분할할 때, 이전 과정의 부분 문제를 해결하는데 사용된 답이 다음 과정의 부분 문제를 해결하는데 필수적으로 사용되도록 분할시켜야 한다는 점인 것 같다. 앞으로 dp 문제를 풀 때 위의 사항을 숙지하여, 엉뚱한 풀이법으로 빠지지 않도록 경계해야겠다.