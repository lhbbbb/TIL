# 최단경로

## 최단경로 문제를 해결하는 방법들

1. 하나의 정점에서 다른 하나의 정점까지의 최단 경로를 구하는 방법
2. 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 방법
3. 하나의 목적지로 가는 모든 최단 경로를 구하는 방법
4. 모든 최단 경로를 구하는 방법

## 다익스트라

* 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 방법
* 간선들은 모두 양의 간선을 가져야 함
* [참고사이트]([https://ratsgo.github.io/data%20structure&algorithm/2017/11/26/dijkstra/](https://ratsgo.github.io/data structure&algorithm/2017/11/26/dijkstra/))

### 관련 문제

* [최소비용](/Algorithm/Samsung/2기서울1반10월17일이현빈/5250_최소비용.py), [최소이동거리](/Algorithm/Samsung/2기서울1반10월17일이현빈/5251_최소이동거리.py)

### 기본 로직

* 첫 정점을 기준으로 연결되어 있는 정점들을 추가해가며, 최단 거리를 갱신
* 정점을 잇기 전까지는 시작점을 제외한 정점들은 모두 무한대의 값을 갖는다
* 너비우선탐색(BFS)를 기본으로 한다

### 구현

1. 현재 정점과 인접한 방문하지 않은 정점들을 찾는다
2. 인접 정점들의 거리를 갱신한다
3. 현재 정점을 방문 처리한다
4. 방문하지 않은 정점 중 거리가 가장 작은 노드로 이동한다
   * 이 작업을 위해 우선순위 큐나 최소 heap을 사용한다
   * 우선순위 큐나 최소 heap을 사용하면 불필요한 업데이트 연산을 줄일 수 있다
5. 모든 정점을 방문 처리할때까지 위의 과정을 반복한다

* 4번 작업을 하지 않아도 다익스트라 알고리즘 구현에는 문제가 없다

```python
def dijkstra(G, s):
    # init setting
    D = [float('inf')] * N
    pi = [0] * N
    visited = [0] * N
    D[s] = 0

    for _ in range(N):
        min_idx = -1
        min_val = float('inf')
        # 인접 노드 중 최소 거리를 갖는 노드 찾기 (priority queue나 최소 heap을 사용하면 더 빨라짐)
        for i in range(N):
            if not visited[i] and D[i] < min_val:
                min_val = D[i]
                min_idx = i
        visited[min_idx] = 1
        # 거리 정보 업데이트
        for v, val in G[min_idx]:
            if not visited[min_idx] and val + D[min_idx] < D[v]:
                D[v] = val + D[min_idx]
                pi[v] = min_idx
```



### 힙을 사용한 다익스트라

* 최소 힙을 사용하여 다익스트라 알고리즘을 구현하면 불필요한 업데이트 연산을 줄일 수 있다

## 플로이드-워셜

* 그래프에서 모든 쌍의 경로 존재 여부를 찾아내는 동적 계획 알고리

## 순열(TSP)

* 가지치기
* DP
* BFS

> 인공지능으로 귀결

## 벨만 포드







